# Chapter 5: Настройка среды и симуляции


В [предыдущей главе](04_абстракция_управления_дроном__offboard__.md) мы рассмотрели [Абстракцию управления дроном (Offboard)](04_абстракция_управления_дроном__offboard__.md) – наш упрощенный пульт для отправки команд дрону вроде "взлетай" или "лети сюда". Теперь, когда мы понимаем все основные программные компоненты нашего проекта (`fr-team-task-rozen`) – от [веб-панели](01_веб_панель_управления_.md) до [логики миссии](02_машина_состояний_миссии_.md) и ["зрения"](03_обработка_видеопотока_и_обнаружение_объектов_.md) – пришло время поговорить о том, как подготовить "сцену" для их запуска и тестирования.

**Зачем нужна настройка среды и симуляция?**

Представьте, что вы строите сложного робота, как наш дрон. Прежде чем запускать его в реальный полет, где он может случайно врезаться или потеряться, было бы здорово иметь безопасное место для тестов. Нам нужна **контролируемая среда**, где все работает одинаково, независимо от того, на чьем компьютере мы запускаем код, и **виртуальный полигон**, где мы можем имитировать полеты без риска для реального оборудования.

Именно эту задачу решают компоненты, которые мы обсудим в этой главе:

1.  **Docker (`Dockerfile`):** Гарантирует, что у всех разработчиков и на сервере будет абсолютно одинаковое окружение со всеми нужными программами и библиотеками.
2.  **Симуляция в Gazebo:** Создает виртуальный 3D-мир, в котором наш программный дрон может "летать", взаимодействовать с объектами и тестировать свое поведение.
3.  **Генерация мира (`generate.py`):** Заполняет наш виртуальный мир в Gazebo нужными объектами для миссии, такими как ArUco-маркеры и модели зданий.
4.  **PX4 SITL (Software In The Loop):** Имитирует работу реального полетного контроллера дрона (его "мозга") прямо на вашем компьютере, взаимодействуя с Gazebo.

Это похоже на подготовку строительной площадки и чертежей перед постройкой настоящего здания. Мы создаем точную виртуальную копию условий, чтобы убедиться, что все работает правильно, прежде чем переходить к реальному миру.

**Ключевые инструменты**

*   **Docker и `Dockerfile`:**
    *   **Что такое Docker?** Представьте себе стандартный транспортный контейнер. Неважно, что внутри – бананы или электроника – его легко перевозить и ставить где угодно, потому что его размеры и крепления стандартные. Docker – это то же самое, но для программного обеспечения. Он упаковывает ваше приложение (наш код для дрона) и все его зависимости (ROS, Python-библиотеки, системные утилиты) в изолированный "контейнер". Этот контейнер можно запустить на любом компьютере, где установлен Docker, и он будет работать *точно так же*, как и на компьютере разработчика.
    *   **Что такое `Dockerfile`?** Это текстовый файл с инструкциями, как построить этот контейнер (называемый "образ"). Это как рецепт: "Возьми базовую систему (Ubuntu с ROS), установи вот эти пакеты, скопируй код проекта сюда, собери его". `Dockerfile` в нашем проекте описывает все шаги для создания среды, готовой к запуску симуляции и кода миссии.

*   **Gazebo:**
    *   **Что это?** Мощный 3D-симулятор для роботов. Он создает виртуальный мир с физикой (гравитация, столкновения), датчиками (камеры, GPS, IMU) и моделями роботов (наш дрон). Мы можем видеть, как дрон летит, как он "видит" мир через свою виртуальную камеру.
    *   **Зачем он нам?** Позволяет тестировать всю систему – от [управления полетом](04_абстракция_управления_дроном__offboard__.md) до [обнаружения объектов](03_обработка_видеопотока_и_обнаружение_объектов_.md) – без риска разбить реальный дрон. Мы можем легко перезапускать симуляцию, менять условия, отлаживать код.

*   **Генерация мира (`generate.py`):**
    *   **Что это?** Скрипт на Python, который автоматически создает файл конфигурации мира (`.world`) для Gazebo.
    *   **Зачем он нужен?** Наша миссия требует наличия в мире определенных объектов: ArUco-маркера (для системы навигации `aruco_map`) и "зданий" (в нашем случае, это могут быть простые цветные метки или модели, которые дрон должен найти). Вместо того чтобы вручную расставлять их в Gazebo, этот скрипт может сделать это программно, например, разместив их случайным образом (но не слишком близко друг к другу). Это позволяет легко создавать разные сценарии для тестирования.

*   **PX4 SITL:**
    *   **Что это?** Software In The Loop (Программа в цикле). Это специальный режим запуска прошивки полетного контроллера PX4 (той же самой, что работает на реальном дроне), но как обычной программы на вашем компьютере.
    *   **Зачем он нужен?** PX4 SITL "думает", что он летит, получая данные от симулятора Gazebo (например, показания виртуальных сенсоров) и отправляя команды на виртуальные моторы в Gazebo. Это позволяет тестировать взаимодействие нашего кода (через MAVROS и [Offboard](04_абстракция_управления_дроном__offboard__.md)) с автопилотом так же, как это было бы на реальном дроне.

**Как все это работает вместе?**

Процесс запуска и тестирования обычно выглядит так:

1.  **Сборка Docker-образа:** Один раз (или при изменениях в `Dockerfile`) выполняется команда типа `docker build`, которая читает `Dockerfile` и создает образ со всеми зависимостями.
2.  **Запуск Docker-контейнера:** Запускается контейнер из созданного образа. Теперь мы находимся внутри изолированной среды Linux с ROS и всем необходимым.
3.  **(Опционально) Генерация мира:** Внутри контейнера запускается скрипт `generate.py`, который создает или обновляет файл `.world` для Gazebo.
4.  **Запуск симуляции:** Внутри контейнера используется команда `roslaunch` (например, `roslaunch clover_simulation simulation.launch`), которая одновременно запускает:
    *   Gazebo с загруженным миром (`.world`).
    *   PX4 SITL.
    *   MAVROS (для связи ROS с PX4).
    *   Другие необходимые узлы ROS (например, серверы сервисов Clover).
5.  **Запуск кода миссии:** В другом терминале (внутри того же контейнера) запускается наш основной скрипт `main.py` (или `mission.py`).
    *   `rosrun offboard main.py`
6.  **Запуск веб-панели:** Если мы хотим использовать [Веб-панель управления](01_веб_панель_управления_.md), запускаем ее веб-сервер (также внутри контейнера):
    *   `rosrun offboard app.py`
7.  **Тестирование:** Открываем веб-панель в браузере на нашем основном компьютере (Docker позволяет "пробросить" порт из контейнера), наблюдаем за дроном в Gazebo и управляем миссией через панель.

**Заглянем под капот: `Dockerfile`**

`Dockerfile` – это сердце нашей воспроизводимой среды. Давайте посмотрим на его ключевые части (сильно упрощено):

```dockerfile
# --- Файл: Dockerfile (упрощено) ---

# 1. Базовый образ: Начинаем с официального образа ROS Noetic для Ubuntu Focal
FROM ros:noetic-ros-base-focal

# 2. Установка системных зависимостей:
# Обновляем списки пакетов и ставим нужные утилиты и библиотеки
RUN apt-get update && apt-get install -q -y --no-install-recommends \
    build-essential \ # Инструменты для сборки
    cmake \
    git \           # Система контроля версий
    python3-pip \   # Установщик пакетов Python
    # ... другие пакеты ...
    && rm -rf /var/lib/apt/lists/* # Чистим кеш

# 3. Настройка ROS:
# Создаем рабочее пространство Catkin и настраиваем переменные окружения
RUN echo "source /opt/ros/noetic/setup.bash" >> ~/.bashrc && \
    source /opt/ros/noetic/setup.bash && \
    mkdir -p ~/catkin_ws/src && \
    cd ~/catkin_ws && \
    catkin_make && \
    echo "source ~/catkin_ws/devel/setup.bash" >> ~/.bashrc && \
    source ~/.bashrc

# 4. Клонирование репозиториев:
# Скачиваем код Clover, нашего проекта и других зависимостей ROS
RUN cd ~/catkin_ws/src && \
    git clone --depth 1 https://github.com/CopterExpress/clover && \
    # ... другие git clone ...
    git clone --recurse-submodules https://gitlab.com/Artemy2807/fr-team-task-rozen

# 5. Установка Python-зависимостей:
# Ставим библиотеки, перечисленные в requirements.txt для Clover и нашего веб-приложения
RUN /usr/bin/python3 -m pip install -r ~/catkin_ws/src/clover/clover/requirements.txt && \
    /usr/bin/python3 -m pip install -r ~/catkin_ws/src/fr-team-task-rozen/offboard/app/requirements.txt

# 6. Установка PX4 SITL:
# Клонируем репозиторий PX4 и устанавливаем зависимости для симуляции
RUN git clone --recursive --depth 1 --branch v1.12.3 https://github.com/PX4/PX4-Autopilot.git ~/PX4-Autopilot
# ... команды установки зависимостей PX4 ...

# 7. Сборка ROS-пакетов:
# Собираем все пакеты в рабочем пространстве Catkin, включая наш fr-team-task-rozen
RUN cd ~/catkin_ws && \
    source /opt/ros/noetic/setup.bash && \
    catkin_make -j10 # Собираем в несколько потоков

# 8. Команда по умолчанию:
# Что делать при запуске контейнера (здесь просто запустить командную строку bash)
CMD ["bash"]
```

*Объяснение:*
*   Каждая команда `RUN` выполняется при сборке образа.
*   Мы начинаем с готового образа ROS (`FROM`).
*   Устанавливаем все, что нужно: системные пакеты (`apt-get`), пакеты Python (`pip`), скачиваем код (`git clone`).
*   Важный шаг – `catkin_make` – собирает все ROS-пакеты, включая наш код из `fr-team-task-rozen`.
*   `CMD ["bash"]` означает, что когда мы запустим контейнер, мы попадем в командную строку внутри него.

**Заглянем под капот: Генерация мира (`generate.py`)**

Этот скрипт отвечает за создание файла `.world`, который Gazebo будет использовать для отрисовки сцены.

```python
# --- Файл: world_generator/scripts/generate.py (упрощено) ---
#!/usr/bin/python3

# ... (импорты: os, numpy, RosPack, math) ...
from rospkg import RosPack

# Получаем путь к нашему пакету world_generator
ROSPACK_INST = RosPack()
WORLD_GEN_PATH = ROSPACK_INST.get_path('world_generator')
CLOVER_SIM_PATH = ROSPACK_INST.get_path('clover_simulation')

# Класс для генерации точек (пропустим детали реализации DiscPoissonGenerator)
# Он помогает расставить точки случайным образом, но не слишком близко
class DiscPoissonGenerator:
    # ... (код для генерации точек) ...
    def __init__(self, width: float, height: float, min_dist: float, points_number: int): pass
    def __iter__(self): pass # Позволяет использовать в цикле for
    def __next__(self): pass # Возвращает следующую точку (x, y)

def main() -> None:
    generated_xml_dronepoints = '' # Здесь будем собирать XML для объектов
    # Путь к моделям "зданий" (простых меток)
    models_path = os.path.join(WORLD_GEN_PATH, 'models/dronepoint')
    # Получаем список имен моделей из этой папки
    models = list(filter(lambda x: os.path.isdir(os.path.join(models_path, x)), os.listdir(models_path)))
    
    # Читаем XML-шаблон для одного "здания"
    dronepoint_template_path = os.path.join(WORLD_GEN_PATH, 'templates', 'dronepoint.world.template')
    with open(dronepoint_template_path, 'r') as file:
        dronepoint_template = file.read()

    print('Генерируем точки для зданий:')
    # Генерируем, например, 5 точек на площадке 7x7 метров с мин. расстоянием 2м
    for point in DiscPoissonGenerator(width=7, height=7, min_dist=2, points_number=5):
        if point is None: continue # Генератор может вернуть None, если не нашел место

        x, y = list(map(lambda coord: round(coord, 2), point)) # Координаты точки
        model = np.random.choice(models) # Выбираем случайную модель/цвет
        name = f'dronepoint_{model}_{str(x).replace(".", "-")}_{str(y).replace(".", "-")}'
        print(f'\tМодель={model}; x={x}; y={y}')

        # Заполняем шаблон XML данными этой точки
        tmp_xml = dronepoint_template.replace("$NAME", name)
        tmp_xml = tmp_xml.replace("$MODEL", model)
        tmp_xml = tmp_xml.replace("$X", str(x))
        tmp_xml = tmp_xml.replace("$Y", str(y))
        generated_xml_dronepoints += tmp_xml # Добавляем к общему XML

    # Читаем основной шаблон мира (с землей, светом, ArUco-маркером)
    template_path = os.path.join(WORLD_GEN_PATH, 'templates', 'default.world.template')
    # Имя выходного файла мира (стандартное для Clover)
    filename = os.path.join(CLOVER_SIM_PATH, 'resources', 'worlds', 'clover_aruco.world')
    print(f'Создаем файл мира: {filename}')

    # Открываем выходной файл для записи
    output_file = open(filename, 'w')
    # Читаем основной шаблон построчно
    with open(template_path, 'r') as d_file:
        for line in d_file:
            # Вставляем сгенерированный XML для "зданий" вместо заглушки
            line = line.replace('$DRONEPOINTS_PLACEHOLDER', generated_xml_dronepoints)
            output_file.write(line) # Пишем строку в выходной файл
    output_file.close()
    print('Мир для Clover успешно создан!')

if __name__ == '__main__':
    main()
```

*Объяснение:*
*   Скрипт использует генератор (`DiscPoissonGenerator`), чтобы получить координаты (x, y) для размещения объектов.
*   Он читает XML-шаблон для одного объекта (`dronepoint.world.template`).
*   В цикле для каждой сгенерированной точки он заполняет этот шаблон, подставляя уникальное имя, случайную модель и координаты (x, y).
*   Весь сгенерированный XML для объектов собирается в строку `generated_xml_dronepoints`.
*   Затем скрипт читает основной шаблон мира (`default.world.template`), который содержит описание земли, освещения и стационарного ArUco-маркера.
*   Он находит в этом шаблоне специальную строку-заглушку (`$DRONEPOINTS_PLACEHOLDER`) и заменяет ее на сгенерированный XML объектов.
*   Результат записывается в файл `clover_aruco.world`, который потом будет загружен Gazebo.

**Запуск симуляции (`roslaunch`)**

ROS предоставляет удобный инструмент `roslaunch` для запуска сразу нескольких программ (узлов ROS) и настройки параметров. Обычно в пакете симуляции (например, `clover_simulation`) есть `.launch`-файлы.

Пример (концептуальный) содержимого `simulation.launch`:

```xml
<!-- Файл simulation.launch (пример) -->
<launch>
  <!-- Запуск Gazebo с нашим миром -->
  <include file="$(find gazebo_ros)/launch/empty_world.launch">
    <arg name="world_name" value="$(find clover_simulation)/resources/worlds/clover_aruco.world"/>
    <!-- другие параметры Gazebo -->
  </include>

  <!-- Запуск PX4 SITL -->
  <node name="sitl" pkg="px4" type="px4" output="screen" 
        args="$(find px4)/ROMFS/px4fmu_common/init.d-posix/rcS" />

  <!-- Запуск MAVROS -->
  <node pkg="mavros" type="mavros_node" name="mavros" output="screen">
    <!-- параметры MAVROS -->
  </node>

  <!-- Запуск сервисов Clover (navigate, get_telemetry и т.д.) -->
  <node pkg="clover" type="simple_offboard" name="simple_offboard" output="screen"/>

  <!-- Другие узлы, если нужны -->

</launch>
```

*Объяснение:*
*   Этот XML-файл говорит `roslaunch`, какие узлы запустить.
*   Он включает стандартный `empty_world.launch` из `gazebo_ros`, но указывает ему загрузить наш сгенерированный мир `clover_aruco.world`.
*   Запускает узел `px4` для SITL.
*   Запускает `mavros_node` для связи с SITL.
*   Запускает узел `simple_offboard` из пакета `clover`, который предоставляет ROS-сервисы, используемые нашей [Абстракцией управления дроном](04_абстракция_управления_дроном__offboard__.md).

**Схема взаимодействия в симуляции:**

```mermaid
graph TD
    subgraph Компьютер Хоста
        subgraph Docker Контейнер
            A[ROS Core (roscore)] --> B;
            A --> C;
            A --> D;
            A --> E;
            A --> F;
            A --> G;

            B(Gazebo) -- Вирт. сенсоры --> E;
            B -- Физика --> C;
            C(PX4 SITL) -- MAVLink --> D;
            D(MAVROS) -- ROS Топики/Сервисы --> E;
            D -- ROS Топики/Сервисы --> F;
            F(Код Миссии main.py) -- Использует сервисы --> E[Сервисы Clover simple_offboard];
            F -- Использует сервисы --> D;
            F -- Публикует статус --> G;
            F -- Запрашивает команды --> G;
            G[Веб-панель app.py] -- HTTP --> H;

            B -- Загружает мир --> I[Файл clover_aruco.world];
            J[Скрипт generate.py] -- Генерирует --> I;

        end
        H(Браузер) -- Взаимодействует --> G;
    end

    style Docker Контейнер fill:#f9f,stroke:#333,stroke-width:2px
```

*Объяснение диаграммы:*
*   Весь "мозг" работает внутри Docker-контейнера.
*   Gazebo симулирует физический мир и сенсоры.
*   PX4 SITL имитирует полетный контроллер.
*   MAVROS связывает PX4 и ROS.
*   Наш код `main.py` (включая [Машину состояний](02_машина_состояний_миссии_.md), [Обработку видео](03_обработка_видеопотока_и_обнаружение_объектов_.md) и [Offboard](04_абстракция_управления_дроном__offboard__.md)) общается со всем через ROS (напрямую или через сервисы Clover).
*   [Веб-панель](01_веб_панель_управления_.md) (`app.py`) также работает в контейнере и общается с браузером на хост-машине.
*   Скрипт `generate.py` создает мир для Gazebo.

**Заключение**

Настройка среды и симуляции – это критически важный этап в разработке робототехнических систем. Использование Docker (`Dockerfile`) гарантирует, что у всех разработчиков будет идентичное и рабочее окружение, что избавляет от многих проблем с зависимостями. Симулятор Gazebo в связке с PX4 SITL предоставляет безопасный и удобный "виртуальный полигон" для тестирования кода управления дроном, его навигации и взаимодействия с миром (например, [обнаружения объектов](03_обработка_видеопотока_и_обнаружение_объектов_.md)) до перехода к реальным полетам. Скрипты генерации мира (`generate.py`) позволяют легко создавать разнообразные сценарии для тестирования.

Владея этими инструментами, вы можете уверенно запускать, тестировать и отлаживать всю систему `fr-team-task-rozen`, которую мы разобрали в предыдущих главах. Это завершает наше погружение в основные компоненты проекта. Удачи в ваших экспериментах с виртуальным (а может, и реальным) дроном!

---

Generated by [AI Codebase Knowledge Builder](https://github.com/The-Pocket/Tutorial-Codebase-Knowledge)